# Encryption Specification

**Status**: Approved
**Author**: Russell Wing, Claude (Opus 4.6)
**Date**: 2026-02-26
**Issue**: [cordelia-core#31](https://github.com/seed-drill/cordelia-core/issues/31)
**Supersedes**: R2-006 Section 6, R5 Sections 4-6, member-removal.md Sections 2-3

---

## 1. Overview

This is the single authoritative specification for Cordelia's encryption architecture. It defines the key hierarchy, data flow, user journeys, and migration path. All other design documents defer to this spec for encryption concerns.

### 1.1 Design Principles

1. **Infrastructure never sees plaintext.** Nodes store and replicate encrypted blobs. Only the entity's devices and the portal (when unlocked by the user) can decrypt.
2. **Every item belongs to a group.** There are no ungrouped items. Privacy is achieved through encryption, not exclusion from replication.
3. **One model for personal and shared groups.** The envelope pattern applies uniformly. No special cases.
4. **The vault passphrase is the trust root.** It protects the vault at rest. It is the recovery mechanism for device loss. Lose your passphrase and all devices = data is irrecoverable.
5. **The node IS the identity.** Ed25519 keypairs are generated by the Rust node. No node, no keys, no encryption.

### 1.2 Threat Model

- **Target**: Curious/determined attackers, not state-level actors
- **Protection scope**: Data at rest on disk and in transit between nodes
- **Accepted risks**: Passphrase in memory during runtime, portal holds PSK in server memory during unlocked session, removed members can decrypt historical items they already received
- **Out of scope**: Side-channel attacks, hardware-level compromise, nation-state adversaries

---

## 2. Key Hierarchy

```
Trust Root: User's vault passphrase (known only to the user)
    |
    v
scrypt(passphrase, vault_salt) --> Vault Master Key (ephemeral, in-memory only)
    |
    +-- Protects vault entries at rest (AES-256-GCM)
    +-- Recovery path for device loss (second encryption of all PSKs)

Identity: Ed25519 keypair (one per node, generated at first startup)
    |
    +-- Ed25519: Signs group descriptors, proves peer identity
    +-- X25519 (derived): Encrypts/decrypts group PSKs in vault
    |
    +-- Public key: stored in portal DB at enrollment (plaintext, public)
    +-- Private key: stored on device at ~/.cordelia/node.key (PKCS#8 DER)

Group PSK: 32-byte random key (one per group, AES-256-GCM)
    |
    +-- Encrypts all items in the group
    +-- Stored in vault, encrypted per-member with their X25519 public key
    +-- Also encrypted with vault passphrase (recovery backup)
    +-- Versioned (key ring) for rotation
```

### 2.1 Key Types

| Key | Type | Size | Purpose | Stored Where |
|-----|------|------|---------|--------------|
| Vault passphrase | User-chosen string | Min 8 chars | Protects vault entries, device recovery | User's memory only |
| Vault master key | scrypt-derived | 32 bytes | Encrypts/decrypts vault entries | Ephemeral (in-memory) |
| Ed25519 keypair | Signing key | 32-byte seed | Peer identity, group descriptor signing | `~/.cordelia/node.key` |
| X25519 keypair | Encryption key | 32 bytes | Encrypts group PSKs per-member | Derived from Ed25519 |
| Group PSK | Symmetric | 32 bytes | Encrypts all items in the group | Vault (per-member encrypted) + device keychain |

### 2.2 What Is Eliminated

The following are deprecated and will be removed after migration:

- `CORDELIA_ENCRYPTION_KEY` environment variable
- scrypt-derived personal key (key_version=1)
- Per-user salt files (`~/.cordelia/memory/L2-warm/.salt/`)
- `SharedKeyVault` stub in keyvault.ts
- The `visibility` column as a decision point (all items are `'group'`)
- Node bridge skip logic for key_version=1 items

---

## 3. Algorithms & Parameters

All implementations (TypeScript proxy, Rust node, portal vault) use identical parameters.

### 3.1 Key Derivation (Vault Only)

| Parameter | Value |
|-----------|-------|
| Algorithm | scrypt |
| N (CPU/memory cost) | 16384 (2^14) |
| r (block size) | 8 |
| p (parallelism) | 1 |
| Output length | 32 bytes |
| Salt | 32 bytes (random, stored per vault entry) |

scrypt is used **only** for vault passphrase -> master key derivation. It is NOT used for item encryption.

### 3.2 Item Encryption

| Parameter | Value |
|-----------|-------|
| Algorithm | AES-256-GCM |
| Key | Group PSK (32 bytes, used directly) |
| IV | 12 bytes (96 bits), random per item |
| Auth tag | 16 bytes (128 bits) |

### 3.3 Key Encryption (Envelope)

| Parameter | Value |
|-----------|-------|
| Key agreement | X25519 (Diffie-Hellman) |
| Derived from | Ed25519 signing key (RFC 8032 -> RFC 7748 conversion) |
| Wrapping | AES-256-GCM with HKDF-derived symmetric key |
| Ephemeral key | X25519, generated per encryption operation |

The envelope encryption for distributing group PSKs uses:

1. Generate ephemeral X25519 keypair
2. X25519 DH(ephemeral_private, recipient_public) -> shared_secret
3. HKDF-SHA256(shared_secret, salt="cordelia-key-wrap-v1") -> wrapping_key
4. AES-256-GCM(wrapping_key, random_iv, group_psk) -> encrypted_psk
5. Store: (ephemeral_public, iv, encrypted_psk, auth_tag)

This is the standard ECIES (Elliptic Curve Integrated Encryption Scheme) construction.

### 3.4 Ed25519 -> X25519 Derivation

The X25519 key is derived from the Ed25519 key using the standard conversion:

- **Private key**: SHA-512 hash of Ed25519 seed, take first 32 bytes, clamp
- **Public key**: Convert Ed25519 public key point to X25519 (Montgomery form)

This is implemented in libsodium (`crypto_sign_ed25519_sk_to_curve25519`) and Rust `ed25519-dalek` / `x25519-dalek` crates.

---

## 4. Encrypted Payload Format

### 4.1 Item Payload (On Wire and At Rest)

```json
{
  "_encrypted": true,
  "version": 2,
  "key_version": 3,
  "iv": "<base64, 12 bytes>",
  "authTag": "<base64, 16 bytes>",
  "ciphertext": "<base64>"
}
```

| Field | Description |
|-------|-------------|
| `_encrypted` | Always `true`. Sentinel for `isEncryptedPayload()` detection. |
| `version` | Payload format version. `1` = legacy (scrypt-derived key). `2` = group PSK. |
| `key_version` | Which version of the group's PSK was used. Indexes into the key ring. |
| `iv` | Random 12-byte IV, base64-encoded. |
| `authTag` | GCM authentication tag, base64-encoded. |
| `ciphertext` | Encrypted JSON content, base64-encoded. |

### 4.2 Vault Entry (Per-Member Encrypted PSK)

```json
{
  "group_id": "<uuid>",
  "member_entity_id": "<string>",
  "ephemeral_public_key": "<base64, 32 bytes>",
  "iv": "<base64, 12 bytes>",
  "auth_tag": "<base64, 16 bytes>",
  "encrypted_psk": "<base64, 32 bytes>",
  "key_version": 1,
  "created_at": "<iso8601>"
}
```

### 4.3 Vault Entry (Passphrase-Protected Backup)

```json
{
  "group_id": "<uuid>",
  "scrypt_salt": "<base64, 32 bytes>",
  "iv": "<base64, 12 bytes>",
  "auth_tag": "<base64, 16 bytes>",
  "encrypted_psk": "<base64, 32 bytes>",
  "key_version": 1,
  "created_at": "<iso8601>"
}
```

---

## 5. User Journeys

### 5.1 First-Time Setup (New User)

```
1. User signs up via portal (OAuth)
2. User installs Cordelia on their device
   - Rust node starts, generates Ed25519 keypair
   - X25519 public key derived from Ed25519
3. User clicks "Enroll Device" in portal
4. Portal shows device code (e.g. ABCD-EFGH)
5. User runs: cordelia enroll --code ABCD-EFGH
6. Portal asks: "Choose a vault passphrase" (first time)
7. User enters passphrase (min 8 chars)
8. User clicks Authorize
9. Behind the scenes:
   a. Device's X25519 public key uploaded to portal
   b. Personal group created (opaque UUID v4)
   c. Personal group PSK generated (32 random bytes)
   d. PSK encrypted with device's X25519 public key -> vault
   e. PSK encrypted with vault passphrase (scrypt) -> vault (recovery backup)
   f. Portal-keeper added as group member (no PSK -- stores ciphertext only)
   g. Bearer token generated for device authentication
10. Device receives: encrypted PSK, bearer token, group UUID, entity_id
11. Device decrypts PSK with Ed25519-derived X25519 private key
12. Device stores PSK in platform keychain
13. Device writes personal_group UUID to ~/.cordelia/config.toml
14. Done -- device is enrolled, encryption is active
```

### 5.2 Adding a Second Device

```
1. User already has Device A enrolled
2. User installs Cordelia on Device B (new node, new Ed25519 keypair)
3. User clicks "Enroll Device" in portal
4. Portal shows new device code
5. User runs: cordelia enroll --code WXYZ-1234 (on Device B)
6. Portal asks: "Enter your vault passphrase" (existing vault)
7. User enters existing passphrase
8. Behind the scenes:
   a. Device B's X25519 public key uploaded to portal
   b. Portal decrypts existing PSK from vault (passphrase recovery path)
   c. Portal re-encrypts PSK with Device B's X25519 public key -> vault
   d. Bearer token generated for Device B
9. Device B receives: encrypted PSK, bearer token, group UUID
10. Device B decrypts PSK with its private key, stores in keychain
11. Existing data replicates from keeper to Device B automatically
12. Device B can decrypt all personal group items
```

### 5.3 Portal Identity (Viewing Encrypted Data in Browser)

```
1. User logs into portal (OAuth)
2. Dashboard shows: groups, devices, network health (unencrypted metadata)
3. Identity section shows: "Enter passphrase to unlock"
4. User enters vault passphrase (or uses passkey/WebAuthn for seamless UX)
5. Portal decrypts personal group PSK from vault (passphrase backup entry)
6. Portal decrypts L1/L2 items from keeper's replicated data
7. Identity cards render: name, preferences, sessions, learnings
8. PSK held in server-side session memory only (never sent to browser)
9. On logout / session expiry: PSK cleared from memory
```

**Future enhancement**: Browser passkeys (WebAuthn) to gate vault access, replacing manual passphrase entry after initial setup.

### 5.4 Creating a Shared Group

```
1. Org admin creates shared group "Seed Drill Internal" via portal
2. Portal generates group PSK (32 random bytes)
3. PSK encrypted with admin's X25519 public key -> vault
4. PSK encrypted with admin's vault passphrase (recovery) -> vault
5. Group descriptor created: UUID, name, culture, owner
6. Group descriptor signed with admin's Ed25519 key
7. Admin's devices receive PSK at next vault sync
```

### 5.5 Joining a Shared Group

```
1. Org admin invites Russell to "Seed Drill Internal"
2. Admin must be unlocked (passphrase entered in portal session)
3. Portal decrypts group PSK from admin's vault entry
4. Portal encrypts group PSK with Russell's X25519 public key -> vault (for Russell)
5. Portal encrypts group PSK with Russell's vault passphrase (recovery) -> vault
6. Russell's device receives encrypted PSK at next enrollment sync
7. Russell decrypts with his X25519 private key, stores in keychain
8. Russell's node begins replicating the shared group
```

**Note**: Admin must be unlocked for the invite. This is the portal-mediated model. A future enhancement allows device-side encryption (admin's device encrypts PSK for new member directly, portal never sees plaintext).

### 5.6 Device Loss and Recovery

```
1. User loses Device A
2. Encrypted data is safe on keeper nodes (replicated)
3. User installs Cordelia on Device B (new keypair)
4. User enrolls Device B via portal
5. User enters vault passphrase
6. Portal decrypts all group PSKs from passphrase backup entries
7. Portal re-encrypts each PSK with Device B's new X25519 public key
8. Device B receives all PSKs, stores in keychain
9. Data replicates from keeper to Device B
10. Full recovery complete
```

**Critical invariant**: Without the vault passphrase, device loss is irrecoverable. The passphrase is the only recovery path.

### 5.7 Member Removal from Shared Group

```
1. Admin removes Russell from "Seed Drill Internal"
2. Russell's nodes stop replicating the group (shared_groups cleared)
3. Admin triggers PSK rotation:
   a. New PSK generated (32 random bytes)
   b. Key version incremented (e.g. v1 -> v2)
   c. New PSK encrypted with each remaining member's X25519 public key -> vault
   d. New PSK encrypted with each remaining member's vault passphrase -> vault
   e. Old PSK retained in key ring for reading historical items
4. Future items encrypted with new PSK
5. Russell can still decrypt items received before removal (acceptable per threat model)
6. Russell cannot decrypt items encrypted after rotation
```

### 5.8 Passphrase Change

```
1. User enters old passphrase -> portal verifies (decrypts a vault entry)
2. User enters new passphrase
3. Portal re-wraps all vault entries with new passphrase (scrypt with new salt)
4. Group PSKs themselves do not change
5. No re-encryption of actual data needed
6. All devices continue working (they have PSKs in keychain)
```

### 5.9 Key Rotation (Suspected Compromise)

```
1. User triggers rotation for personal group (or admin for shared group)
2. New PSK generated (32 random bytes)
3. Key version incremented
4. New PSK encrypted per-member + per-passphrase -> vault
5. Old PSK retained in key ring
6. All new items encrypted with new PSK (new key_version)
7. Historical items readable via key ring (old key_version -> old PSK)
8. Devices receive new PSK at next vault sync
```

### 5.10 Agent/Bot Access

```
1. Agent (e.g. Claude via MCP) connects to proxy
2. Proxy holds all group PSKs in memory (loaded from keychain at startup)
3. Agent reads/writes via MCP tools (memory_read, memory_write)
4. Proxy encrypts on write, decrypts on read -- agent never touches keys
5. Agent inherits user's full group access (same as the device owner)
```

**Future enhancement**: Scoped agent tokens that restrict which groups an agent can access, independent of which PSKs the proxy holds.

---

## 6. Component Responsibilities

### 6.1 Rust Node

- Generates and stores Ed25519 keypair (identity)
- Stores encrypted blobs in SQLite (never decrypts)
- Replicates blobs via P2P (GroupExchange, EagerPush, anti-entropy)
- Signs group descriptors with Ed25519 key
- Exposes X25519 public key via API for enrollment
- **Never has access to any PSK or plaintext content**

### 6.2 TypeScript Proxy

- Loads group PSKs from platform keychain at startup
- Encrypts items before writing to node (AES-256-GCM with group PSK)
- Decrypts items after reading from node
- Manages KeyVault interface (getGroupKey, rotateGroupKey)
- Provides MCP interface to agents (encrypt/decrypt is transparent)
- Handles enrollment: receives encrypted PSK, decrypts with X25519 private key, stores in keychain

### 6.3 Portal

- Stores vault entries (encrypted PSKs) in portal database
- Mediates key distribution: encrypts PSK per-member using their X25519 public key
- Stores passphrase-protected backup copies of all PSKs
- Handles enrollment flow (RFC 8628 device authorization)
- Decrypts PSK for portal display (per-session, in-memory only)
- Stores member X25519 public keys (plaintext, public data)
- **Never stores plaintext PSKs persistently**

### 6.4 Keeper Node

- Stores and replicates encrypted blobs (same as any node)
- Participates in GroupExchange (advertises group descriptors)
- **Does not possess any group PSK**
- **Cannot decrypt any content** -- functions as an encrypted backup service

---

## 7. Vault Schema

### 7.1 Tables

```sql
-- Per-member encrypted PSK (envelope encryption)
CREATE TABLE vault_group_keys (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    entity_id TEXT NOT NULL,          -- member who can decrypt this entry
    group_id TEXT NOT NULL,           -- which group's PSK
    key_version INTEGER NOT NULL,     -- PSK version (key ring index)
    ephemeral_public_key BLOB NOT NULL, -- X25519 ephemeral pubkey (32 bytes)
    iv BLOB NOT NULL,                 -- AES-256-GCM IV (12 bytes)
    auth_tag BLOB NOT NULL,           -- AES-256-GCM auth tag (16 bytes)
    encrypted_psk BLOB NOT NULL,      -- AES-256-GCM ciphertext (32 bytes)
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(entity_id, group_id, key_version)
);

-- Passphrase-protected PSK backup (recovery path)
CREATE TABLE vault_recovery_keys (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    entity_id TEXT NOT NULL,          -- user who owns this backup
    group_id TEXT NOT NULL,           -- which group's PSK
    key_version INTEGER NOT NULL,     -- PSK version
    scrypt_salt BLOB NOT NULL,        -- scrypt salt (32 bytes)
    iv BLOB NOT NULL,                 -- AES-256-GCM IV (12 bytes)
    auth_tag BLOB NOT NULL,           -- AES-256-GCM auth tag (16 bytes)
    encrypted_psk BLOB NOT NULL,      -- AES-256-GCM ciphertext (32 bytes)
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(entity_id, group_id, key_version)
);

-- Member public keys (plaintext, public data)
CREATE TABLE member_public_keys (
    entity_id TEXT PRIMARY KEY,
    x25519_public_key BLOB NOT NULL,  -- 32 bytes
    ed25519_public_key BLOB NOT NULL, -- 32 bytes
    uploaded_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

### 7.2 Legacy Tables (Deprecated, Remove After Migration)

- `vault_keys` -- stores passphrase-as-key for key_version=1 (replaced by vault_group_keys)
- `vault_salts` -- stores scrypt salt for key_version=1 (eliminated: PSKs are used directly)
- `vault_psk` -- stores personal group PSK (replaced by vault_group_keys)

---

## 8. Key Ring

Each group maintains a key ring: an ordered list of PSK versions.

```
Group "Seed Drill Internal":
  key_version=1: PSK_a (created 2026-02-26, active)
  key_version=2: PSK_b (created 2026-03-15, active) <-- current
```

**Encryption** always uses the latest version.

**Decryption** looks up the item's `key_version` field and uses the corresponding PSK from the ring.

The key ring is stored in the vault: one `vault_group_keys` row per (entity, group, version). Each member holds the full ring for their groups.

**Cleanup**: Old key versions may be pruned after all items at that version have been re-encrypted or expired. This is a manual operation (no automatic pruning).

---

## 9. Migration from key_version=1

### 9.1 Phase 1: Infrastructure

- Implement X25519 key derivation from Ed25519 in Rust and TypeScript
- Update enrollment to distribute PSK via envelope encryption (not passphrase)
- Create new vault tables (vault_group_keys, vault_recovery_keys, member_public_keys)
- Implement KeyVault backed by group PSK files + vault sync

### 9.2 Phase 2: New Items Use Group PSK

- All new L1/L2 writes use group PSK with `key_version >= 1` (payload version=2)
- Existing items remain with payload version=1 (scrypt-derived key)
- Proxy maintains backward-compatible decryption for version=1 items
- Node bridge stops skipping any encrypted items (replicate everything)

### 9.3 Phase 3: Backfill

- Re-encrypt existing items from version=1 to version=2
- Set `group_id`, `key_version` on migrated items
- After all items migrated, remove version=1 decryption codepath

### 9.4 Phase 4: Cleanup

- Remove `CORDELIA_ENCRYPTION_KEY` env var support
- Remove scrypt key derivation from item encryption path (keep for vault passphrase only)
- Remove salt file management
- Remove `SharedKeyVault` stub
- Drop legacy vault tables
- Remove node bridge skip logic

---

## 10. Metadata (Not Encrypted)

The following metadata is transmitted in plaintext for routing and replication purposes. This is an accepted trade-off documented in `metadata-privacy.md`.

- `group_id` (opaque UUID for personal groups)
- `item_id`, `item_type`
- `author_id`
- `key_version`
- `updated_at`, `created_at`
- `checksum`
- `parent_id`, `is_copy`, `is_deletion`
- Encrypted blob length

Group descriptors (culture, owner_id, signature) are also plaintext.

Personal group UUIDs are opaque (not derived from entity_id), preventing entity-to-group correlation by relay nodes.

---

## 11. Future Capabilities (Out of Scope)

These are explicitly deferred. The current design accommodates them via clean interfaces.

| Capability | Interface | Notes |
|-----------|-----------|-------|
| **Device-side group invite** | KeyVault.distributeKey() | Admin's device encrypts PSK for new member directly. Portal never sees plaintext. |
| **Scoped agent tokens** | PolicyEngine.evaluate() | Restrict which groups an agent can access, independent of available PSKs. |
| **Full Signal envelope** | KeyVault (swap implementation) | Per-member public key encryption with key escrow table. Current PSK model is the interface. |
| **Browser passkeys (WebAuthn)** | Portal auth layer | Gates vault unlock with biometrics instead of passphrase entry. |
| **Sealed GroupExchange** | Network layer | Encrypt group descriptors to prevent metadata leakage. |
| **Padding** | Proxy layer | Fixed-size encrypted blobs to prevent size fingerprinting. |
| **Re-encryption on member removal** | KeyVault.reencryptItems() | Nuclear departure policy. Current standard policy is rotate-forward only. |

---

## 12. Test Cases

### 12.1 Enrollment

- [ ] First device enrollment generates personal group + PSK
- [ ] PSK is encrypted with device's X25519 public key in vault
- [ ] PSK is encrypted with vault passphrase (recovery) in vault
- [ ] Device decrypts PSK and stores in keychain
- [ ] Portal-keeper is added as group member without PSK

### 12.2 Second Device

- [ ] Existing PSK is distributed to second device
- [ ] Both devices derive the same AES key (same PSK)
- [ ] Item encrypted on Device A is decryptable on Device B

### 12.3 Portal Display

- [ ] Portal cannot decrypt items without passphrase unlock
- [ ] After unlock, portal decrypts L1/L2 from keeper data
- [ ] PSK is cleared from memory on logout
- [ ] PSK is never sent to the browser

### 12.4 Shared Group

- [ ] Group creation generates PSK, encrypted per-member
- [ ] Invite distributes PSK to new member via X25519 envelope
- [ ] Invited member can decrypt group items
- [ ] Non-member cannot decrypt group items

### 12.5 Key Rotation

- [ ] New PSK generated, old retained in key ring
- [ ] New items use new key_version
- [ ] Historical items readable via old key_version
- [ ] Removed member cannot decrypt post-rotation items

### 12.6 Recovery

- [ ] Device loss: new device recovers via passphrase + vault
- [ ] Passphrase change: re-wraps vault, data unchanged
- [ ] Wrong passphrase: vault decryption fails cleanly

### 12.7 Migration (key_version=1 -> 2)

- [ ] Existing v1 items remain readable during migration
- [ ] New items use v2 (group PSK)
- [ ] After backfill, all items are v2
- [ ] v1 codepath removed after cleanup

---

## 13. References

- **Whitepaper Section 8**: Security model, encryption invariants
- **R2-006 Section 1.5**: Envelope encryption design principle (now implemented here)
- **R5 Personal Groups**: Personal group model (encryption sections superseded by this doc)
- **Threat Model**: Algorithm parameters, trust boundaries, accepted risks
- **Metadata Privacy**: Plaintext metadata inventory
- **Member Removal**: Departure policies (key rotation sections superseded by this doc)
- **RFC 7748**: X25519 key agreement
- **RFC 8032**: Ed25519 signatures
- **ECIES**: Elliptic Curve Integrated Encryption Scheme

---

*This document is the single source of truth for Cordelia's encryption architecture. It supersedes the encryption sections in R2-006, R5, and member-removal.md.*
